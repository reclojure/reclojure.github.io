{
"version":3,
"file":"goog.crypt.base64.js",
"lineCount":155,
"mappings":"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",
"sources":["goog/crypt/base64.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base64 en/decoding. Not much to say here except that we\n * work with decoded values in arrays of bytes. By \"byte\" I mean a number\n * in [0, 255].\n */\n\ngoog.provide('goog.crypt.base64');\n\ngoog.require('goog.asserts');\ngoog.require('goog.crypt');\ngoog.require('goog.string');\ngoog.require('goog.userAgent');\ngoog.require('goog.userAgent.product');\n\n/**\n * Default alphabet, shared between alphabets. Only 62 characters.\n * @private {string}\n */\ngoog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n    'abcdefghijklmnopqrstuvwxyz' +\n    '0123456789';\n\n\n/**\n * Alphabet characters for Alphabet.DEFAULT encoding.\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '+/=';\n\n\n/**\n * Alphabet characters for Alphabet.WEBSAFE_DOT_PADDING encoding.\n * The dot padding is no Internet Standard, according to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64_URL_SAFE` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_WEBSAFE =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '-_.';\n\n\n/**\n * Alphabets for Base64 encoding\n * Alphabets with no padding character are for encoding without padding.\n * About the alphabets, please refer to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * @enum {number}\n */\ngoog.crypt.base64.Alphabet = {\n  DEFAULT: 0,\n  NO_PADDING: 1,\n  WEBSAFE: 2,\n  WEBSAFE_DOT_PADDING: 3,\n  WEBSAFE_NO_PADDING: 4,\n};\n\n\n/**\n * Padding chars for Base64 encoding\n * @const {string}\n * @private\n */\ngoog.crypt.base64.paddingChars_ = '=.';\n\n\n/**\n * Check if a character is a padding character\n *\n * @param {string} char\n * @return {boolean}\n * @private\n */\ngoog.crypt.base64.isPadding_ = function(char) {\n  'use strict';\n  return goog.string.contains(goog.crypt.base64.paddingChars_, char);\n};\n\n\n// Static lookup maps, lazily populated by init_()\n\n/**\n * For each `Alphabet`, maps from bytes to characters.\n *\n * @see https://jsperf.com/char-lookups\n * @type {!Object<!goog.crypt.base64.Alphabet, !Array<string>>}\n * @private\n */\ngoog.crypt.base64.byteToCharMaps_ = {};\n\n/**\n * Maps characters to bytes.\n *\n * This map is used for all alphabets since, across alphabets, common chars\n * always map to the same byte.\n *\n * `null` indicates `init` has not yet been called.\n *\n * @type {?Object<string, number>}\n * @private\n */\ngoog.crypt.base64.charToByteMap_ = null;\n\n\n/**\n * White list of implementations with known-good native atob and btoa functions.\n * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code\n * removal in per-browser compilations.\n * @private {boolean}\n */\ngoog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO ||\n    (goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI) ||\n    goog.userAgent.OPERA;\n\n\n/**\n * Does this browser have a working btoa function?\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_ENCODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    typeof(goog.global.btoa) == 'function';\n\n\n/**\n * Does this browser have a working atob function?\n * We blacklist known-bad implementations:\n *  - IE (10+) added atob() but it does not tolerate whitespace on the input.\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_DECODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&\n     typeof(goog.global.atob) == 'function');\n\n\n/**\n * Base64-encode an array of bytes.\n *\n * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n *     value in [0, 255]) to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeByteArray = function(input, alphabet) {\n  'use strict';\n  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce\n  // size of jscompiler output, and which yields slight performance increase.\n  goog.asserts.assert(\n      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');\n\n  if (alphabet === undefined) {\n    alphabet = goog.crypt.base64.Alphabet.DEFAULT;\n  }\n\n  goog.crypt.base64.init_();\n\n  var byteToCharMap = goog.crypt.base64.byteToCharMaps_[alphabet];\n\n  var output = [];\n\n  for (var i = 0; i < input.length; i += 3) {\n    var byte1 = input[i];\n    var haveByte2 = i + 1 < input.length;\n    var byte2 = haveByte2 ? input[i + 1] : 0;\n    var haveByte3 = i + 2 < input.length;\n    var byte3 = haveByte3 ? input[i + 2] : 0;\n\n    var outByte1 = byte1 >> 2;\n    var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n    var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);\n    var outByte4 = byte3 & 0x3F;\n\n    if (!haveByte3) {\n      outByte4 = 64;\n\n      if (!haveByte2) {\n        outByte3 = 64;\n      }\n    }\n\n    output.push(\n        byteToCharMap[outByte1], byteToCharMap[outByte2],\n        byteToCharMap[outByte3] || '', byteToCharMap[outByte4] || '');\n  }\n\n  return output.join('');\n};\n\n\n/**\n * Base64-encode a string.\n *\n * @param {string} input A string to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeString = function(input, alphabet) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {\n    return goog.global.btoa(input);\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToByteArray(input), alphabet);\n};\n\n\n/**\n * Base64-decode a string.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeString = function(input, useCustomDecoder) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !useCustomDecoder) {\n    return goog.global.atob(input);\n  }\n  var output = '';\n  function pushByte(b) {\n    output += String.fromCharCode(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to an Array of numbers.\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.\n * @return {!Array<number>} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {\n  'use strict';\n  var output = [];\n  function pushByte(b) {\n    output.push(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to a Uint8Array.\n *\n * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.\n * @see http://caniuse.com/uint8array\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @return {!Uint8Array} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToUint8Array = function(input) {\n  'use strict';\n  goog.asserts.assert(\n      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher('10'),\n      'Browser does not support typed arrays');\n  var len = input.length;\n  // Approximate the length of the array needed for output.\n  // Our method varies according to the format of the input, which we can\n  // consider in three categories:\n  //   A) well-formed with proper padding\n  //   B) well-formed without any padding\n  //   C) not-well-formed, either with extra whitespace in the middle or with\n  //      extra padding characters.\n  //\n  //  In the case of (A), (length * 3 / 4) will result in an integer number of\n  //  bytes evenly divisible by 3, and we need only subtract bytes according to\n  //  the padding observed.\n  //\n  //  In the case of (B), (length * 3 / 4) will result in a non-integer number\n  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible\n  //  by 3, it's well-formed with the proper amount of padding [0 padding]).\n  //  This approximation can become exact by rounding down.\n  //\n  //  In the case of (C), the only way to get the length is to walk the full\n  //  length of the string to consider each character. This is handled by\n  //  tracking the number of bytes added to the array and using subarray to\n  //  trim the array back down to size.\n  var approxByteLength = len * 3 / 4;\n  if (approxByteLength % 3) {\n    // The string isn't complete, either because it didn't include padding, or\n    // because it has extra white space.\n    // In either case, we won't generate more bytes than are completely encoded,\n    // so rounding down is appropriate to have a buffer at least as large as\n    // output.\n    approxByteLength = Math.floor(approxByteLength);\n  } else if (goog.crypt.base64.isPadding_(input[len - 1])) {\n    // The string has a round length, and has some padding.\n    // Reduce the byte length according to the quantity of padding.\n    if (goog.crypt.base64.isPadding_(input[len - 2])) {\n      approxByteLength -= 2;\n    } else {\n      approxByteLength -= 1;\n    }\n  }\n  var output = new Uint8Array(approxByteLength);\n  var outLen = 0;\n  function pushByte(b) {\n    output[outLen++] = b;\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  // Return a subarray to handle the case that input included extra whitespace\n  // or extra padding and approxByteLength was incorrect.\n  return output.subarray(0, outLen);\n};\n\n\n/**\n * @param {string} input Input to decode.\n * @param {function(number):void} pushByte result accumulator.\n * @private\n */\ngoog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {\n  'use strict';\n  goog.crypt.base64.init_();\n\n  var nextCharIndex = 0;\n  /**\n   * @param {number} default_val Used for end-of-input.\n   * @return {number} The next 6-bit value, or the default for end-of-input.\n   */\n  function getByte(default_val) {\n    while (nextCharIndex < input.length) {\n      var ch = input.charAt(nextCharIndex++);\n      var b = goog.crypt.base64.charToByteMap_[ch];\n      if (b != null) {\n        return b;  // Common case: decoded the char.\n      }\n      if (!goog.string.isEmptyOrWhitespace(ch)) {\n        throw new Error('Unknown base64 encoding at char: ' + ch);\n      }\n      // We encountered whitespace: loop around to the next input char.\n    }\n    return default_val;  // No more input remaining.\n  }\n\n  while (true) {\n    var byte1 = getByte(-1);\n    var byte2 = getByte(0);\n    var byte3 = getByte(64);\n    var byte4 = getByte(64);\n\n    // The common case is that all four bytes are present, so if we have byte4\n    // we can skip over the truncated input special case handling.\n    if (byte4 === 64) {\n      if (byte1 === -1) {\n        return;  // Terminal case: no input left to decode.\n      }\n      // Here we know an intermediate number of bytes are missing.\n      // The defaults for byte2, byte3 and byte4 apply the inferred padding\n      // rules per the public API documentation. i.e: 1 byte\n      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield\n      // a single byte of output. (Recall that 64 corresponds the padding char).\n    }\n\n    var outByte1 = (byte1 << 2) | (byte2 >> 4);\n    pushByte(outByte1);\n\n    if (byte3 != 64) {\n      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);\n      pushByte(outByte2);\n\n      if (byte4 != 64) {\n        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;\n        pushByte(outByte3);\n      }\n    }\n  }\n};\n\n\n/**\n * Lazy static initialization function. Called before\n * accessing any of the static map variables.\n * @private\n */\ngoog.crypt.base64.init_ = function() {\n  'use strict';\n  if (goog.crypt.base64.charToByteMap_) {\n    return;\n  }\n  goog.crypt.base64.charToByteMap_ = {};\n\n  // We want quick mappings back and forth, so we precompute encoding maps.\n\n  /** @type {!Array<string>} */\n  var commonChars = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split('');\n  var specialChars = [\n    '+/=',  // DEFAULT\n    '+/',   // NO_PADDING\n    '-_=',  // WEBSAFE\n    '-_.',  // WEBSAFE_DOT_PADDING\n    '-_',   // WEBSAFE_NO_PADDING\n  ];\n\n  for (var i = 0; i < 5; i++) {\n    // `i` is each value of the `goog.crypt.base64.Alphabet` enum\n    var chars = commonChars.concat(specialChars[i].split(''));\n\n    // Sets byte-to-char map\n    goog.crypt.base64\n        .byteToCharMaps_[/** @type {!goog.crypt.base64.Alphabet} */ (i)] =\n        chars;\n\n    // Sets char-to-byte map\n    for (var j = 0; j < chars.length; j++) {\n      var char = chars[j];\n\n      var existingByte = goog.crypt.base64.charToByteMap_[char];\n      if (existingByte === undefined) {\n        goog.crypt.base64.charToByteMap_[char] = j;\n      } else {\n        goog.asserts.assert(existingByte === j);\n      }\n    }\n  }\n};\n"],
"names":["goog","provide","require","crypt","base64","DEFAULT_ALPHABET_COMMON_","ENCODED_VALS","ENCODED_VALS_WEBSAFE","Alphabet","DEFAULT","NO_PADDING","WEBSAFE","WEBSAFE_DOT_PADDING","WEBSAFE_NO_PADDING","paddingChars_","isPadding_","goog.crypt.base64.isPadding_","char","string","contains","byteToCharMaps_","charToByteMap_","ASSUME_NATIVE_SUPPORT_","userAgent","GECKO","WEBKIT","product","SAFARI","OPERA","HAS_NATIVE_ENCODE_","global","btoa","HAS_NATIVE_DECODE_","IE","atob","encodeByteArray","goog.crypt.base64.encodeByteArray","input","alphabet","asserts","assert","isArrayLike","undefined","init_","byteToCharMap","output","i","length","byte1","haveByte2","byte2","haveByte3","byte3","outByte1","outByte2","outByte3","outByte4","push","join","encodeString","goog.crypt.base64.encodeString","stringToByteArray","decodeString","goog.crypt.base64.decodeString","useCustomDecoder","pushByte","b","String","fromCharCode","decodeStringInternal_","decodeStringToByteArray","goog.crypt.base64.decodeStringToByteArray","opt_ignored","decodeStringToUint8Array","goog.crypt.base64.decodeStringToUint8Array","isVersionOrHigher","len","approxByteLength","Math","floor","Uint8Array","outLen","subarray","goog.crypt.base64.decodeStringInternal_","nextCharIndex","getByte","default_val","ch","charAt","isEmptyOrWhitespace","Error","byte4","goog.crypt.base64.init_","commonChars","split","specialChars","chars","concat","j","existingByte"]
}
